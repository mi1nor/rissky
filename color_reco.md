...Распознование цвета платформы

Давайте, представим такую ситуацию, что вам нужно с помощью дрона распознать цвет какой-либо фигуры/объекта. Для этого нам потребуется как минимум камера, ведь именно от него исходит цвет этого объекта. Для этого нам также потребуется библиотека OpenCV (Open Computer Vision), с помощью которой мы и будем распознавать цвет.

Как вы могли подумать, чтобы распознать цвет, то нужно будет использовать распознавание цвета по RGB, то есть, просто по его цвету. Но это в корне не так.

Дело в том, что если бы мы использовали RGB, то банально он может не распознать очень много объектов. Условно, мы зададим ему значение цвета по RGB, но мы учтем тот факт, что его цвет может быть темным или слишком светлым, ища красный цвет, он может быть малиновым или вишневым и т.д. Поэтому, мы должны использовать HSV (оттенок цвета, насыщенность, велечина). Там, те параметры которые используются для RGB, совсем не подходят, ибо банально там нет велечины оттенка или его насыщенности. То есть, если в RGB красный - (255, 0, 0), то в HSV он может быть от (0, ~100, ~100) и до (~15, 255, 255).

img...

Мы не будем углубляться, как он распознает через камеру цвет и тому подобному, ибо там используются высшая математика: матрицы и т.д, но в этом курсе многие могут не знать этого, поэтому, опустим этот момент.

Давайте же приступим к тому, как добавить специальный цвет на симуляторе, или же платформу, где мы потом будем распознавать его цвет.

`Добавляем платформу в симуляторе`

Для того, чтобы распознать, что это вообще за цвет, то нам будет удобнее создать платформу с таким цветом, которого нет на поле.

Чтобы создать платформу в симуляторе, то вам надо будет нажать на куб на верхней панельке, нажать и поставить его на поле. После чего, нажимаете на этот куб правой кнопкой мыши, и переходите во вкладку "Edit model".

img... https://imgur.com/a/PmoUp4i

Вас перенесет на "страничку", где вы сможете изменить весь ваш куб. Нам нужна платформа желательно яркого цвета и чтобы она была маленькой. Для этого, нажмите на "Open Link Inspector", найдите во вкладку "Visual" такой параметр, как "Geometry". Здесь, вам нужно будет изменить сам объем вашего куба. Желательно, используйте те значения, которые показаны на скриншоте. Потом вы проделываете все так же во вкладку "Collision".

img... https://imgur.com/a/ZoqcnNk

Дальше, нам понадобится поменять цвет самой платформы, это можно сделать во вкладке "Visual", и изменить значения в "Ambient" и "Diffuse", на примерно такие, если вы хотите получить красный цвет.

img... https://imgur.com/a/belizFh

После того, как вы все сделали, то нажимайте вкладку "OK", но не спешите выходить из самого редактора, ведь вам придется сохранить этот объект. Нажмите сверху вкладку "File" и нажмите "Save As", затем, у вас вылезет окошко, где вы можете переминовать название объекта, или, можете просто сразу нажать "Save". После сохранения, то вы можете спокойно выходить из редактора.

img... https://imgur.com/a/VgBTdms

Как вы вышли из редактора, вы можете переместить вашу платформу с помощью мышью или просто слева забить ему нужные вам координаты.

img... https://imgur.com/a/LShkQAM

`Узнаем HSV значение цвета`

Давайте же приступим к самой главной части это урока: написанию кода.

Наш код будет устроен так, что мы будем брать изображение из камеры, потом само изображение преобразовывать в HSV, но будем брать мы только центр изображения с камеры, то есть, примерно 1 пиксель, чтобы считался только и другие не считались вообще, то есть, ваш дрон должен быть ровно над платформой. Потом, мы просто будем выводить значение этого HSV.

Давайте приступим:

```
from cv_bridge import CvBridge # Чтобы брать изображение
from sensor_msgs.msg import Image # Для топика камеры
import cv2 # OpenCV

bridge = CvBridge()

color = 'error' # Иницилизируем наш текст
def color_callback(data):
    global color # Делаем ее глобальной, чтобы потом можно было вызвать из любого места
    cv_image = bridge.imgmsg_to_cv2(data, 'bgr8') # Берем изображение из топика камеры
    img_hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV) # Переводим изображение в HSV
    
    # Чтобы знать значения цвета в HSV, 119... это центр камеры
    print(img_hsv[119][159])

# Нужно добавить ноду image_raw_throttled, иначе используйте image_raw
image_sub = rospy.Subscriber("main_camera/image_raw_throttled", Image, color_callback)
```

Давайте же запустим этот код, и когда наш дрон будет подлетать к платформе, то он будет выводить нынешние значения этой самой платформы. Давайте запомним или сохраним эти значения.

img... https://imgur.com/a/LE6wOo2

`Полноценный код`

После того, как мы узнали значение самой платформы, то нам нужно будет отсортировать код так, чтобы именно эти значения считались за нами нужными. Но как это сделать?

Это сделать довольно легко. Вы должны просто создать пару параметров, где в каждом из них будет возможная минимальное значение по HSV, как и максимальное. Потом, вы просто берете функцию, где если это значение, которое распозналось, походит под минимальное и максимальное HSV.

```
from cv_bridge import CvBridge # Чтобы брать изображение
from sensor_msgs.msg import Image # Для топика камеры
import cv2 # OpenCV

bridge = CvBridge()

color = 'error' # Инициализируем наш текст
def color_callback(data):
    global color # Делаем ее глобальной, чтобы потом можно было вызвать из любого места
    cv_image = bridge.imgmsg_to_cv2(data, 'bgr8') # Берем изображение из топика камеры
    img_hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)[119:120, 159:160]
    # Самое последнее, где 119... это пиксель центра камеры
    
    # От симулятора и в жизни могут отличаться значения
    red_low_value = (0, 150, 200) # Минимальное примерное
    red_high_value = (10, 255, 255) # Максимальное примерное
    
    # Вы можете просто брать среднее арифметическое самого цвета, где 1 параметр вы можете
    # добавить и убавить в 1 параметры по 10 едениц, а 2 и 3 от 30 до 50, в самом где (..., ..., )
    
    # В каких областях будет детектиться цвет
    red_final = cv2.inRange(img_hsv, red_low_value, red_high_value)
    
    # Если он находится в таких значениях, то выводит, что это красный цвет
    if red_final[0][0] == 255:
        color = 'red'
    else:
        color = 'error'

# Нужно добавить ноду image_raw_throttled, иначе используйте image_raw
image_sub = rospy.Subscriber("main_camera/image_raw_throttled", Image, color_callback)
```

Теперь вы можете тестировать ваш код. Но этот код, вы должны будете вставить в свой, где у вас уже прописан путь и т.д

Как мы видим, то наш код все распознает.

img... https://imgur.com/a/8nHsnCY
